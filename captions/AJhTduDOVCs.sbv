0:00:00.300,0:00:04.980
have you ever been in a situation where your 
database queries are slow and you need to speed

0:00:04.980,0:00:09.900
them up while keeping costs down I'd like you 
to imagine for a moment you've built a movie

0:00:09.900,0:00:15.480
streaming platform that is growing quickly when 
you started you decided to use mongodb to store

0:00:15.480,0:00:20.700
and retrieve movies this worked really well for 
a while and now things are starting to break down

0:00:21.780,0:00:26.880
you've already attempted to optimize your queries 
to mongodb and you are able to squeak out a little

0:00:26.880,0:00:32.700
more performance but it wasn't enough you know you 
need to Cache your queries in redis but you want

0:00:32.700,0:00:39.060
to make sure you keep costs down this is where the 
cache aside pattern comes in handy the goal of the

0:00:39.060,0:00:44.160
cache aside pattern is to set up optimal caching 
for data retrieval on demand so rather than

0:00:44.160,0:00:49.440
syncing your entire database with redis from the 
start you'll fill redis as your data is requested

0:00:49.440,0:00:55.140
when an application requests data you first see 
if that data exists in redis if it exists you can

0:00:55.140,0:01:00.960
quickly return it if it doesn't exist you fetch 
the data from your database and store it in redis

0:01:00.960,0:01:06.720
for future requests then return the data to the 
application let's see how you might implement the

0:01:06.720,0:01:13.200
cache aside pattern in code here I'm using node.js 
with the mongodb client and the redisome library

0:01:14.040,0:01:19.200
first I'll create a function to create a hash 
key based on the search criteria this will be

0:01:19.200,0:01:24.240
used to store and retrieve Keys from redis next 
I'll create a function to find the top movies

0:01:25.140,0:01:31.560
in it I'll get my [ __ ] and redis connections 
then create my search criteria for now I'm

0:01:31.560,0:01:35.880
looking for movies in English that have an 
IMDb rating greater than or equal to 8.5

0:01:37.380,0:01:41.100
now I need to get the hash 
key to use to search redis

0:01:41.940,0:01:48.360
if I find a value in redis then I log the cache 
hit and return the value if I don't find the

0:01:48.360,0:01:55.560
value in redis I log a cache Miss and then search 
mongodb for the movies finally I store the results

0:01:55.560,0:02:01.500
from mongodb in redis making sure to expire 
them after 30 seconds and return the results

0:02:03.060,0:02:06.840
let's run this function twice to 
see if we get the expected result

0:02:08.700,0:02:14.760
when I run the script you can see I first 
get a cache Miss then a subsequent cash hit

0:02:15.360,0:02:19.620
this is the expected result since we 
started with nothing in our redis database

0:02:20.280,0:02:28.740
in redis Insight you'll see our stored string with 
the expiration date when I click the value you can

0:02:28.740,0:02:35.460
see the stringified result for mongodb even though 
this is a string I can inform redis Insight that

0:02:35.460,0:02:42.300
I'm looking at Json and it will display it in a 
format that is easier to read if you plan to use

0:02:42.300,0:02:47.220
the cache aside pattern and store your queries in 
redis as strings one thing you'll need to decide

0:02:47.220,0:02:52.860
on your own is how frequently you want to expire 
the data you don't want the expiration time to be

0:02:52.860,0:02:58.500
too short but if it's too long it can lead to 
data consistency problems one way to solve the

0:02:58.500,0:03:03.780
data consistency issue is to use another pattern 
called the right behind or right through pattern

0:03:03.780,0:03:08.640
this is something that I will discuss in a future 
video however another way to mitigate some of the

0:03:08.640,0:03:13.560
data consistency issues is to get more granular 
with how you store and retrieve data from redis

0:03:13.560,0:03:19.500
with redis stack you can Store and search Json 
documents in redis so we can rewrite our code

0:03:19.500,0:03:24.300
to Store and search redis just like we do with 
mongodb let's look at what that might look like

0:03:25.500,0:03:30.780
here I'm using node.js like before only 
this time I'm creating a movie collection

0:03:30.780,0:03:36.420
in redis using redisome each movie will have 
the same fields that I'm storing in mongodb

0:03:37.920,0:03:44.760
to find the top movies I first get my mongodb 
and redis connections then I get the redis movie

0:03:44.760,0:03:51.780
Repository next I search the repository for 
movies in English with an IMDb rating greater

0:03:51.780,0:03:58.200
than or equal to 8.5 the result will always 
be an array so for my purposes I'm comfortable

0:03:58.200,0:04:03.180
saying that if the array is not empty then 
it's a cash hit otherwise it's a cache Miss

0:04:04.020,0:04:09.780
for cash misses I get the results from 
mongodb then I iterate over the results

0:04:09.780,0:04:16.260
and store each value in redis you see here 
that I didn't set an expiration on my data

0:04:16.260,0:04:21.420
for this to work you'll need to determine the 
best time to delete the data from the cache

0:04:21.420,0:04:26.820
typically what people do is delete the data in 
redis whenever they delete or update it in mongodb

0:04:28.380,0:04:32.820
let's run the fine top movies function 
twice and see if we get the expected results

0:04:36.840,0:04:41.220
when I run the script I first get a 
cache Miss then a subsequent cash hit

0:04:41.760,0:04:45.540
this is expected since we started 
with nothing in our redis database

0:04:46.380,0:04:51.060
looking at our data in redis Insight you 
can see we now have a collection of movie

0:04:51.060,0:04:56.340
Json documents instead of before where we 
only had a single key with a string value

0:04:56.340,0:05:02.520
note that there is no expiration on the movie 
documents this is because our application will

0:05:02.520,0:05:07.020
take care of deleting and updating these 
documents whenever they change in mongodb

0:05:08.100,0:05:13.560
if I click on a movie document you can see that 
it is storing all of the movie information that

0:05:13.560,0:05:19.860
we defined in our schema remember the cache aside 
pattern is useful when you need to query data

0:05:19.860,0:05:24.900
frequently and want to fill your cache on demand 
to save on cost if you're interested in learning

0:05:24.900,0:05:29.580
more about storing and searching Master data 
in redis check out our ebook that covers three

0:05:29.580,0:05:34.380
design patterns to speed up mirn applications 
the link is in the description down below

0:05:36.480,0:05:38.200
foreign [Music]
